{"version":3,"sources":["knockout.mapping.min.js"],"names":["factory","require","exports","module","define","ko","Error","mapping","unionArrays","i","j","k","args","arguments","l","length","obj","res","push","extendObject","destination","source","destType","key","hasOwnProperty","getType","bothArrays","merge","obj1","obj2","merged","fillOptions","rawOptions","otherOptions","options","recognizedRootProperties","property","Object","ignore","mergeArrays","include","copy","observe","defaultOptions","mappedProperties","copiedProperties","a","b","undefined","utils","arrayGetDistinctValues","concat","withProxyDependentObservable","dependentObservables","callback","localDO","dependentObservable","read","owner","realDeferEvaluation","deferEvaluation","isRemoved","wrap","DO","tmp","realKoDependentObservable","isWriteable","isWriteableObservable","wrapped","arrayRemoveItem","apply","write","val","__DO","realDependentObservable","fn","computed","result","updateViewModel","mappedRootObject","rootObject","parentName","parent","parentPropertyName","mappedParent","isArray","unwrapObservable","isMapped","previousMapping","mappingProperty","callbackParams","data","hasCreateCallback","create","Function","createCallback","Array","skip","emptyReturn","hasUpdateCallback","update","updateCallback","params","target","observable","alreadyMapped","visitedObjects","get","changes","hasKeyCallback","keyCallback","x","isObservable","observableArray","mappedRemove","valueOrPredicate","predicate","value","remove","item","mappedRemoveAll","arrayOfValues","arrayOfKeys","filterArrayByKey","arrayIndexOf","mappedDestroy","destroy","mappedDestroyAll","mappedIndexOf","keys","mappedGet","mappedCreate","newValue","currentArrayKeys","sort","newArrayKeys","editScript","compareArrays","ignoreIndexOf","unwrappedRootObject","itemsByKey","optimizedKeys","index","newContents","passedOver","mappedItem","fullPropertyName","status","getItemByKey","ignorableIndexOf","event","arrayChanged","arrayForEach","change","canHaveProperties","save","visitPropertiesOrArrayEntries","indexer","prevMappedProperty","retval","valueToWrite","hasCreateOrUpdateCallback","array","ignoreIndices","mapKey","arrayMap","visitorCallback","propertyName","object","type","getPropertyName","SimpleObjectLookup","values","this","existingIndex","ObjectLookup","buckets","findBucket","bucketKey","e","bucket","mappingNesting","_defaultOptions","viewModel","unwrapped","fromJS","jsObject","pop","fromJSON","jsonString","prototype","slice","call","parseJson","toJS","resetDefaultOptions","visitModel","toJSON","plainJavaScriptObject","stringifyJson","constructor","Date","propertyValue","unwrappedRootMappingProperty","previouslyMappedValue"],"mappings":"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","file":"knockout.mapping.min.js","sourcesContent":["/*!\n * Knockout Mapping plugin v2.5.0\n * (c) 2013 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n */\n(function(factory) {\n    'use strict';\n\n    /*jshint sub:true,curly:false*/\n    /*global ko,require,exports,define,module*/\n\n    if (typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\") {\n        // CommonJS or Node: hard-coded dependency on \"knockout\"\n        factory(require(\"knockout\"), exports);\n    }\n    else if (typeof define === \"function\" && define[\"amd\"]) {\n        // AMD anonymous module with hard-coded dependency on \"knockout\"\n        define([\"knockout\", \"exports\"], factory);\n    }\n    else {\n        // <script> tag: use the global `ko` object, attaching a `mapping` property\n        if (typeof ko === 'undefined') {\n            throw new Error('Knockout is required, please ensure it is loaded before loading this mapping plug-in');\n        }\n        factory(ko, ko.mapping = {});\n    }\n}(function(ko, exports) {\n    /*jshint sub:true,curly:false*/\n    'use strict';\n\n    ko.mapping = exports;\n\n    const DEBUG=false;\n    var mappingProperty = \"__ko_mapping__\";\n    var realKoDependentObservable = ko.dependentObservable;\n    var mappingNesting = 0;\n    var dependentObservables;\n    var visitedObjects;\n    var recognizedRootProperties = [\"create\", \"update\", \"key\", \"arrayChanged\"];\n    var emptyReturn = {};\n\n    var _defaultOptions = {\n        include: [\"_destroy\"],\n        ignore: [],\n        copy: [],\n        observe: []\n    };\n    var defaultOptions = _defaultOptions;\n\n    function unionArrays() {\n        var args = arguments,\n            l = args.length,\n            obj = {},\n            res = [],\n            i, j, k;\n\n        while (l--) {\n            k = args[l];\n            i = k.length;\n\n            while (i--) {\n                j = k[i];\n                if (!obj[j]) {\n                    obj[j] = 1;\n                    res.push(j);\n                }\n            }\n        }\n\n        return res;\n    }\n\n    function extendObject(destination, source) {\n        var destType;\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key) && source[key]) {\n                destType = exports.getType(destination[key]);\n                if (key && destination[key] && destType !== \"array\" && destType !== \"string\") {\n                    extendObject(destination[key], source[key]);\n                }\n                else {\n                    var bothArrays = exports.getType(destination[key]) === \"array\" && exports.getType(source[key]) === \"array\";\n                    if (bothArrays) {\n                        destination[key] = unionArrays(destination[key], source[key]);\n                    }\n                    else {\n                        destination[key] = source[key];\n                    }\n                }\n            }\n        }\n    }\n\n    function merge(obj1, obj2) {\n        var merged = {};\n        extendObject(merged, obj1);\n        extendObject(merged, obj2);\n\n        return merged;\n    }\n\n    exports.isMapped = function(viewModel) {\n        var unwrapped = ko.utils.unwrapObservable(viewModel);\n        return unwrapped && unwrapped[mappingProperty];\n    };\n\n    exports.fromJS = function(jsObject /*, inputOptions, target*/) {\n        if (arguments.length === 0) {\n            throw new Error(\"When calling ko.fromJS, pass the object you want to convert.\");\n        }\n        try {\n            if (!mappingNesting) {\n                dependentObservables = [];\n                visitedObjects = new ObjectLookup();\n            }\n            mappingNesting++;\n\n            var options;\n            var target;\n\n            if (arguments.length === 2) {\n                if (arguments[1][mappingProperty]) {\n                    target = arguments[1];\n                }\n                else {\n                    options = arguments[1];\n                }\n            }\n            if (arguments.length === 3) {\n                options = arguments[1];\n                target = arguments[2];\n            }\n\n            if (target) {\n                options = merge(options, target[mappingProperty]);\n            }\n            options = fillOptions(options);\n\n            var result = updateViewModel(target, jsObject, options);\n            if (target) {\n                result = target;\n            }\n\n            // Evaluate any dependent observables that were proxied.\n            // Do this after the model's observables have been created\n            if (!--mappingNesting) {\n                while (dependentObservables.length) {\n                    var DO = dependentObservables.pop();\n                    if (DO) {\n                        DO();\n                        // Move this magic property to the underlying dependent observable\n                        DO.__DO[\"throttleEvaluation\"] = DO[\"throttleEvaluation\"];\n                    }\n                }\n            }\n\n            // Save any new mapping options in the view model, so that updateFromJS can use them later.\n            result[mappingProperty] = merge(result[mappingProperty], options);\n\n            return result;\n        }\n        catch (e) {\n            mappingNesting = 0;\n            throw e;\n        }\n    };\n\n    exports.fromJSON = function(jsonString /*, options, target*/) {\n        var args = Array.prototype.slice.call(arguments, 0);\n        args[0] = ko.utils.parseJson(jsonString);\n        return exports.fromJS.apply(this, args);\n    };\n\n    exports.toJS = function(rootObject, options) {\n        if (!defaultOptions) exports.resetDefaultOptions();\n\n        if (arguments.length === 0) throw new Error(\"When calling ko.mapping.toJS, pass the object you want to convert.\");\n        if (exports.getType(defaultOptions.ignore) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().ignore should be an array.\");\n        if (exports.getType(defaultOptions.include) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().include should be an array.\");\n        if (exports.getType(defaultOptions.copy) !== \"array\") throw new Error(\"ko.mapping.defaultOptions().copy should be an array.\");\n\n        // Merge in the options used in fromJS\n        options = fillOptions(options, rootObject[mappingProperty]);\n\n        // We just unwrap everything at every level in the object graph\n        return exports.visitModel(rootObject, function(x) {\n            return ko.utils.unwrapObservable(x);\n        }, options);\n    };\n\n    exports.toJSON = function(rootObject, options) {\n        var plainJavaScriptObject = exports.toJS(rootObject, options);\n        return ko.utils.stringifyJson(plainJavaScriptObject);\n    };\n\n    exports.defaultOptions = function() {\n        if (arguments.length > 0) {\n            defaultOptions = arguments[0];\n        }\n        else {\n            return defaultOptions;\n        }\n    };\n\n    exports.resetDefaultOptions = function() {\n        defaultOptions = {\n            include: _defaultOptions.include.slice(0),\n            ignore: _defaultOptions.ignore.slice(0),\n            copy: _defaultOptions.copy.slice(0),\n            observe: _defaultOptions.observe.slice(0)\n        };\n    };\n\n    exports.getType = function(x) {\n        if ((x) && (typeof (x) === \"object\")) {\n            if (x.constructor === Date) return \"date\";\n            if (x.constructor === Array) return \"array\";\n        }\n        return typeof x;\n    };\n\n    function fillOptions(rawOptions, otherOptions) {\n        var options = merge({}, rawOptions);\n\n        // Move recognized root-level properties into a root namespace\n        for (var i = recognizedRootProperties.length - 1; i >= 0; i--) {\n            var property = recognizedRootProperties[i];\n\n            // Carry on, unless this property is present\n            if (!options[property]) continue;\n\n            // Move the property into the root namespace\n            if (!(options[\"\"] instanceof Object)) options[\"\"] = {};\n            options[\"\"][property] = options[property];\n            delete options[property];\n        }\n\n        if (otherOptions) {\n            options.ignore = mergeArrays(otherOptions.ignore, options.ignore);\n            options.include = mergeArrays(otherOptions.include, options.include);\n            options.copy = mergeArrays(otherOptions.copy, options.copy);\n            options.observe = mergeArrays(otherOptions.observe, options.observe);\n        }\n        options.ignore = mergeArrays(options.ignore, defaultOptions.ignore);\n        options.include = mergeArrays(options.include, defaultOptions.include);\n        options.copy = mergeArrays(options.copy, defaultOptions.copy);\n        options.observe = mergeArrays(options.observe, defaultOptions.observe);\n\n        options.mappedProperties = options.mappedProperties || {};\n        options.copiedProperties = options.copiedProperties || {};\n        return options;\n    }\n\n    function mergeArrays(a, b) {\n        if (a === undefined) {\n            a = [];\n        }\n        else if (exports.getType(a) !== \"array\") {\n            a = [a];\n        }\n\n        if (b === undefined) {\n            b = [];\n        }\n        else if (exports.getType(b) !== \"array\") {\n            b = [b];\n        }\n\n        return ko.utils.arrayGetDistinctValues(a.concat(b));\n    }\n\n    // When using a 'create' callback, we proxy the dependent observable so that it doesn't immediately evaluate on creation.\n    // The reason is that the dependent observables in the user-specified callback may contain references to properties that have not been mapped yet.\n    function withProxyDependentObservable(dependentObservables, callback) {\n        var localDO = ko.dependentObservable;\n        ko.dependentObservable = function(read, owner, options) {\n            options = options || {};\n\n            if (read && typeof read === \"object\") { // mirrors condition in knockout implementation of DO's\n                options = read;\n            }\n\n            var realDeferEvaluation = options.deferEvaluation;\n\n            var isRemoved = false;\n\n            // We wrap the original dependent observable so that we can remove it from the 'dependentObservables' list we need to evaluate after mapping has\n            // completed if the user already evaluated the DO themselves in the meantime.\n            var wrap = function(DO) {\n                // Temporarily revert ko.dependentObservable, since it is used in ko.isWriteableObservable\n                var tmp = ko.dependentObservable;\n                ko.dependentObservable = realKoDependentObservable;\n                var isWriteable = ko.isWriteableObservable(DO);\n                ko.dependentObservable = tmp;\n\n                var wrapped = realKoDependentObservable({\n                    read: function() {\n                        if (!isRemoved) {\n                            ko.utils.arrayRemoveItem(dependentObservables, DO);\n                            isRemoved = true;\n                        }\n                        return DO.apply(DO, arguments);\n                    },\n                    write: isWriteable && function(val) {\n                        return DO(val);\n                    },\n                    deferEvaluation: true\n                });\n                if (DEBUG) wrapped._wrapper = true;\n                wrapped.__DO = DO;\n                return wrapped;\n            };\n\n            options.deferEvaluation = true; // will either set for just options, or both read/options.\n            var realDependentObservable = realKoDependentObservable(read, owner, options);\n\n            if (!realDeferEvaluation) {\n                realDependentObservable = wrap(realDependentObservable);\n                dependentObservables.push(realDependentObservable);\n            }\n\n            return realDependentObservable;\n        };\n        ko.dependentObservable.fn = realKoDependentObservable.fn;\n        ko.computed = ko.dependentObservable;\n        var result = callback();\n        ko.dependentObservable = localDO;\n        ko.computed = ko.dependentObservable;\n        return result;\n    }\n\n    function updateViewModel(mappedRootObject, rootObject, options, parentName, parent, parentPropertyName, mappedParent) {\n        var isArray = exports.getType(ko.utils.unwrapObservable(rootObject)) === \"array\";\n\n        parentPropertyName = parentPropertyName || \"\";\n\n        // If this object was already mapped previously, take the options from there and merge them with our existing ones.\n        if (exports.isMapped(mappedRootObject)) {\n            var previousMapping = ko.utils.unwrapObservable(mappedRootObject)[mappingProperty];\n            options = merge(previousMapping, options);\n        }\n\n        var callbackParams = {\n            data: rootObject,\n            parent: mappedParent || parent\n        };\n\n        var hasCreateCallback = function() {\n            return options[parentName] && options[parentName].create instanceof Function;\n        };\n\n        var createCallback = function(data) {\n            return withProxyDependentObservable(dependentObservables, function() {\n\n                if (ko.utils.unwrapObservable(parent) instanceof Array) {\n                    return options[parentName].create({\n                        data: data || callbackParams.data,\n                        parent: callbackParams.parent,\n                        skip: emptyReturn\n                    });\n                }\n                else {\n                    return options[parentName].create({\n                        data: data || callbackParams.data,\n                        parent: callbackParams.parent\n                    });\n                }\n            });\n        };\n\n        var hasUpdateCallback = function() {\n            return options[parentName] && options[parentName].update instanceof Function;\n        };\n\n        var updateCallback = function(obj, data) {\n            var params = {\n                data: data || callbackParams.data,\n                parent: callbackParams.parent,\n                target: ko.utils.unwrapObservable(obj)\n            };\n\n            if (ko.isWriteableObservable(obj)) {\n                params.observable = obj;\n            }\n\n            return options[parentName].update(params);\n        };\n\n        var alreadyMapped = visitedObjects.get(rootObject);\n        if (alreadyMapped) {\n            return alreadyMapped;\n        }\n\n        parentName = parentName || \"\";\n\n        if (!isArray) {\n            // For atomic types, do a direct update on the observable\n            if (!canHaveProperties(rootObject)) {\n                switch (exports.getType(rootObject)) {\n                    case \"function\":\n                        if (hasUpdateCallback()) {\n                            if (ko.isWriteableObservable(rootObject)) {\n                                rootObject(updateCallback(rootObject));\n                                mappedRootObject = rootObject;\n                            }\n                            else {\n                                mappedRootObject = updateCallback(rootObject);\n                            }\n                        }\n                        else {\n                            mappedRootObject = rootObject;\n                        }\n                        break;\n                    default:\n                        if (ko.isWriteableObservable(mappedRootObject)) {\n                            var valueToWrite;\n                            if (hasUpdateCallback()) {\n                                valueToWrite = updateCallback(mappedRootObject);\n                                mappedRootObject(valueToWrite);\n                                return valueToWrite;\n                            }\n                            else {\n                                valueToWrite = ko.utils.unwrapObservable(rootObject);\n                                mappedRootObject(valueToWrite);\n                                return valueToWrite;\n                            }\n                        }\n                        else {\n                            var hasCreateOrUpdateCallback = hasCreateCallback() || hasUpdateCallback();\n\n                            if (hasCreateCallback()) {\n                                mappedRootObject = createCallback();\n                            }\n                            else {\n                                mappedRootObject = ko.observable(ko.utils.unwrapObservable(rootObject));\n                            }\n\n                            if (hasUpdateCallback()) {\n                                mappedRootObject(updateCallback(mappedRootObject));\n                            }\n\n                            if (hasCreateOrUpdateCallback) return mappedRootObject;\n                        }\n                }\n\n            }\n            else {\n                mappedRootObject = ko.utils.unwrapObservable(mappedRootObject);\n                if (!mappedRootObject) {\n                    if (hasCreateCallback()) {\n                        var result = createCallback();\n\n                        if (hasUpdateCallback()) {\n                            result = updateCallback(result);\n                        }\n                        return result;\n                    }\n                    else {\n                        if (hasUpdateCallback()) {\n                            //Removed ambiguous parameter result\n                            return updateCallback();\n                        }\n                        mappedRootObject = {};\n                    }\n                }\n\n                if (hasUpdateCallback()) {\n                    mappedRootObject = updateCallback(mappedRootObject);\n                }\n\n                visitedObjects.save(rootObject, mappedRootObject);\n                if (hasUpdateCallback()) return mappedRootObject;\n\n                // For non-atomic types, visit all properties and update recursively\n                visitPropertiesOrArrayEntries(rootObject, function(indexer) {\n                    var fullPropertyName = parentPropertyName.length ? parentPropertyName + \".\" + indexer : indexer;\n\n                    if (ko.utils.arrayIndexOf(options.ignore, fullPropertyName) !== -1) {\n                        return;\n                    }\n\n                    if (ko.utils.arrayIndexOf(options.copy, fullPropertyName) !== -1) {\n                        mappedRootObject[indexer] = rootObject[indexer];\n                        return;\n                    }\n\n                    if (typeof rootObject[indexer] !== \"object\" && exports.getType(rootObject[indexer]) !== \"array\" && options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) === -1) {\n                        mappedRootObject[indexer] = rootObject[indexer];\n                        options.copiedProperties[fullPropertyName] = true;\n                        return;\n                    }\n\n                    // In case we are adding an already mapped property, fill it with the previously mapped property value to prevent recursion.\n                    // If this is a property that was generated by fromJS, we should use the options specified there\n                    var prevMappedProperty = visitedObjects.get(rootObject[indexer]);\n                    var retval = updateViewModel(mappedRootObject[indexer], rootObject[indexer], options, indexer, mappedRootObject, fullPropertyName, mappedRootObject);\n                    var value = prevMappedProperty || retval;\n\n                    if (options.observe.length > 0 && ko.utils.arrayIndexOf(options.observe, fullPropertyName) === -1) {\n                        mappedRootObject[indexer] = ko.utils.unwrapObservable(value);\n                        options.copiedProperties[fullPropertyName] = true;\n                        return;\n                    }\n\n                    if (ko.isWriteableObservable(mappedRootObject[indexer])) {\n                        value = ko.utils.unwrapObservable(value);\n                        if (mappedRootObject[indexer]() !== value) {\n                            mappedRootObject[indexer](value);\n                        }\n                    }\n                    else {\n                        value = mappedRootObject[indexer] === undefined ? value : ko.utils.unwrapObservable(value);\n                        mappedRootObject[indexer] = value;\n                    }\n\n                    options.mappedProperties[fullPropertyName] = true;\n                });\n            }\n        }\n        else { //mappedRootObject is an array\n            var changes = [];\n\n            var hasKeyCallback = false;\n            var keyCallback = function(x) {\n                return x;\n            };\n            if (options[parentName] && options[parentName].key) {\n                keyCallback = options[parentName].key;\n                hasKeyCallback = true;\n            }\n\n            if (!ko.isObservable(mappedRootObject)) {\n                // When creating the new observable array, also add a bunch of utility functions that take the 'key' of the array items into account.\n                mappedRootObject = ko.observableArray([]);\n\n                mappedRootObject.mappedRemove = function(valueOrPredicate) {\n                    var predicate = typeof valueOrPredicate === \"function\" ? valueOrPredicate : function(value) {\n                        return value === keyCallback(valueOrPredicate);\n                    };\n                    return mappedRootObject.remove(function(item) {\n                        return predicate(keyCallback(item));\n                    });\n                };\n\n                mappedRootObject.mappedRemoveAll = function(arrayOfValues) {\n                    var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n                    return mappedRootObject.remove(function(item) {\n                        return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) !== -1;\n                    });\n                };\n\n                mappedRootObject.mappedDestroy = function(valueOrPredicate) {\n                    var predicate = typeof valueOrPredicate === \"function\" ? valueOrPredicate : function(value) {\n                        return value === keyCallback(valueOrPredicate);\n                    };\n                    return mappedRootObject.destroy(function(item) {\n                        return predicate(keyCallback(item));\n                    });\n                };\n\n                mappedRootObject.mappedDestroyAll = function(arrayOfValues) {\n                    var arrayOfKeys = filterArrayByKey(arrayOfValues, keyCallback);\n                    return mappedRootObject.destroy(function(item) {\n                        return ko.utils.arrayIndexOf(arrayOfKeys, keyCallback(item)) !== -1;\n                    });\n                };\n\n                mappedRootObject.mappedIndexOf = function(item) {\n                    var keys = filterArrayByKey(mappedRootObject(), keyCallback);\n                    var key = keyCallback(item);\n                    return ko.utils.arrayIndexOf(keys, key);\n                };\n\n                mappedRootObject.mappedGet = function(item) {\n                    return mappedRootObject()[mappedRootObject.mappedIndexOf(item)];\n                };\n\n                mappedRootObject.mappedCreate = function(value) {\n                    if (mappedRootObject.mappedIndexOf(value) !== -1) {\n                        throw new Error(\"There already is an object with the key that you specified.\");\n                    }\n                    var item = hasCreateCallback() ? createCallback(value) : value;\n                    if (hasUpdateCallback()) {\n                        var newValue = updateCallback(item, value);\n                        if (ko.isWriteableObservable(item)) {\n                            item(newValue);\n                        }\n                        else {\n                            item = newValue;\n                        }\n                    }\n                    mappedRootObject.push(item);\n                    return item;\n                };\n            }\n\n            var currentArrayKeys = filterArrayByKey(ko.utils.unwrapObservable(mappedRootObject), keyCallback).sort();\n            var newArrayKeys = filterArrayByKey(rootObject, keyCallback);\n            if (hasKeyCallback) newArrayKeys.sort();\n            var editScript = ko.utils.compareArrays(currentArrayKeys, newArrayKeys);\n\n            var ignoreIndexOf = {};\n\n            var i, j, key;\n\n            var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n            var itemsByKey = {};\n            var optimizedKeys = true;\n            for (i = 0, j = unwrappedRootObject.length; i < j; i++) {\n                key = keyCallback(unwrappedRootObject[i]);\n                if (key === undefined || key instanceof Object) {\n                    optimizedKeys = false;\n                    break;\n                }\n                itemsByKey[key] = unwrappedRootObject[i];\n            }\n\n            var newContents = [];\n            var passedOver = 0;\n            var item, index;\n\n            for (i = 0, j = editScript.length; i < j; i++) {\n                key = editScript[i];\n                var mappedItem;\n                var fullPropertyName = parentPropertyName + \"[\" + i + \"]\";\n                switch (key.status) {\n                    case \"added\":\n                        item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n                        mappedItem = updateViewModel(undefined, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n                        if (!hasCreateCallback()) {\n                            mappedItem = ko.utils.unwrapObservable(mappedItem);\n                        }\n\n                        index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n\n                        if (mappedItem === emptyReturn) {\n                            passedOver++;\n                        }\n                        else {\n                            newContents[index - passedOver] = mappedItem;\n                        }\n\n                        ignoreIndexOf[index] = true;\n                        break;\n                    case \"retained\":\n                        item = optimizedKeys ? itemsByKey[key.value] : getItemByKey(ko.utils.unwrapObservable(rootObject), key.value, keyCallback);\n                        mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n                        updateViewModel(mappedItem, item, options, parentName, mappedRootObject, fullPropertyName, parent);\n\n                        index = ignorableIndexOf(ko.utils.unwrapObservable(rootObject), item, ignoreIndexOf);\n                        newContents[index] = mappedItem;\n                        ignoreIndexOf[index] = true;\n                        break;\n                    case \"deleted\":\n                        mappedItem = getItemByKey(mappedRootObject, key.value, keyCallback);\n                        break;\n                }\n\n                changes.push({\n                    event: key.status,\n                    item: mappedItem\n                });\n            }\n\n            mappedRootObject(newContents);\n\n            if (options[parentName] && options[parentName].arrayChanged) {\n                ko.utils.arrayForEach(changes, function(change) {\n                    options[parentName].arrayChanged(change.event, change.item);\n                });\n            }\n        }\n\n        return mappedRootObject;\n    }\n\n    function ignorableIndexOf(array, item, ignoreIndices) {\n        for (var i = 0, j = array.length; i < j; i++) {\n            if (ignoreIndices[i] === true) continue;\n            if (array[i] === item) return i;\n        }\n        return null;\n    }\n\n    function mapKey(item, callback) {\n        var mappedItem;\n        if (callback) mappedItem = callback(item);\n        if (exports.getType(mappedItem) === \"undefined\") mappedItem = item;\n\n        return ko.utils.unwrapObservable(mappedItem);\n    }\n\n    function getItemByKey(array, key, callback) {\n        array = ko.utils.unwrapObservable(array);\n        for (var i = 0, j = array.length; i < j; i++) {\n            var item = array[i];\n            if (mapKey(item, callback) === key) return item;\n        }\n\n        throw new Error(\"When calling ko.update*, the key '\" + key + \"' was not found!\");\n    }\n\n    function filterArrayByKey(array, callback) {\n        return ko.utils.arrayMap(ko.utils.unwrapObservable(array), function(item) {\n            if (callback) {\n                return mapKey(item, callback);\n            }\n            else {\n                return item;\n            }\n        });\n    }\n\n    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {\n        if (exports.getType(rootObject) === \"array\") {\n            for (var i = 0; i < rootObject.length; i++)\n                visitorCallback(i);\n        }\n        else {\n            for (var propertyName in rootObject) {\n                if (rootObject.hasOwnProperty(propertyName)) {\n                    visitorCallback(propertyName);\n                }\n            }\n        }\n    }\n\n    function canHaveProperties(object) {\n        if (object === null) {\n            return false;\n        }\n        var type = exports.getType(object);\n        return (type === \"object\") || (type === \"array\");\n    }\n\n    // Based on the parentName, this creates a fully classified name of a property\n\n    function getPropertyName(parentName, parent, indexer) {\n        var propertyName = parentName || \"\";\n        if (exports.getType(parent) === \"array\") {\n            if (parentName) {\n                propertyName += \"[\" + indexer + \"]\";\n            }\n        }\n        else {\n            if (parentName) {\n                propertyName += \".\";\n            }\n            propertyName += indexer;\n        }\n        return propertyName;\n    }\n\n    exports.visitModel = function(rootObject, callback, options) {\n        options = options || {};\n        options.visitedObjects = options.visitedObjects || new ObjectLookup();\n\n        var mappedRootObject;\n        var unwrappedRootObject = ko.utils.unwrapObservable(rootObject);\n\n        if (!canHaveProperties(unwrappedRootObject)) {\n            return callback(rootObject, options.parentName);\n        }\n        else {\n            options = fillOptions(options, unwrappedRootObject[mappingProperty]);\n\n            // Only do a callback, but ignore the results\n            callback(rootObject, options.parentName);\n            mappedRootObject = exports.getType(unwrappedRootObject) === \"array\" ? [] : {};\n        }\n\n        options.visitedObjects.save(rootObject, mappedRootObject);\n\n        var parentName = options.parentName;\n        visitPropertiesOrArrayEntries(unwrappedRootObject, function(indexer) {\n            if (options.ignore && ko.utils.arrayIndexOf(options.ignore, indexer) !== -1) return;\n\n            var propertyValue = unwrappedRootObject[indexer];\n            options.parentName = getPropertyName(parentName, unwrappedRootObject, indexer);\n\n            // If we don't want to explicitly copy the unmapped property...\n            if (ko.utils.arrayIndexOf(options.copy, indexer) === -1) {\n                // ...find out if it's a property we want to explicitly include\n                if (ko.utils.arrayIndexOf(options.include, indexer) === -1) {\n                    // The mapped properties object contains all the properties that were part of the original object.\n                    // If a property does not exist, and it is not because it is part of an array (e.g. \"myProp[3]\"), then it should not be unmapped.\n                    var unwrappedRootMappingProperty = unwrappedRootObject[mappingProperty];\n                    if (unwrappedRootMappingProperty) {\n                        var mappedProperties = unwrappedRootMappingProperty.mappedProperties;\n                        if (mappedProperties && !mappedProperties[indexer]) {\n                            var copiedProperties = unwrappedRootMappingProperty.copiedProperties;\n                            if (copiedProperties && !copiedProperties[indexer] && (exports.getType(unwrappedRootObject) !== \"array\")) {\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n\n            switch (exports.getType(ko.utils.unwrapObservable(propertyValue))) {\n                case \"object\":\n                case \"array\":\n                case \"undefined\":\n                    var previouslyMappedValue = options.visitedObjects.get(propertyValue);\n                    mappedRootObject[indexer] = (exports.getType(previouslyMappedValue) !== \"undefined\") ? previouslyMappedValue : exports.visitModel(propertyValue, callback, options);\n                    break;\n                default:\n                    mappedRootObject[indexer] = callback(propertyValue, options.parentName);\n            }\n        });\n\n        return mappedRootObject;\n    };\n\n    function SimpleObjectLookup() {\n        var keys = [];\n        var values = [];\n        this.save = function(key, value) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            if (existingIndex >= 0) values[existingIndex] = value;\n            else {\n                keys.push(key);\n                values.push(value);\n            }\n        };\n        this.get = function(key) {\n            var existingIndex = ko.utils.arrayIndexOf(keys, key);\n            var value = (existingIndex >= 0) ? values[existingIndex] : undefined;\n            return value;\n        };\n    }\n\n    function ObjectLookup() {\n        var buckets = {};\n\n        var findBucket = function(key) {\n            var bucketKey;\n            try {\n                bucketKey = key;//JSON.stringify(key);\n            }\n            catch (e) {\n                bucketKey = \"$$$\";\n            }\n\n            var bucket = buckets[bucketKey];\n            if (!buckets.hasOwnProperty(bucketKey)) {\n                bucket = new SimpleObjectLookup();\n                buckets[bucketKey] = bucket;\n            }\n            return bucket;\n        };\n\n        this.save = function(key, value) {\n            findBucket(key).save(key, value);\n        };\n        this.get = function(key) {\n            return findBucket(key).get(key);\n        };\n    }\n}));\n"],"sourceRoot":"/source/"}